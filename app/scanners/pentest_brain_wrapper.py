"""
Wrapper for AI Pentest Brain integration with backend
This module provides a clean interface to run scans from the backend
"""

import sys
import json
import asyncio
import subprocess
from pathlib import Path
from typing import Dict, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

# Path to the pentest brain script
PENTEST_BRAIN_PATH = Path(__file__).parent.parent.parent.parent / "ai_pentest_brain_complete.py"


async def run_pentest_scan(
    target_url: str,
    scan_mode: str = "common",
    execution_mode: str = "report_only",
    timeout: int = 300
) -> Dict[str, Any]:
    """
    Run a penetration test scan using the AI Pentest Brain
    
    Args:
        target_url: Target URL to scan
        scan_mode: Scan mode (common, fast, full, stealth, aggressive, custom)
        execution_mode: Execution mode (report_only, dry_run, apply_fixes)
        timeout: Timeout in seconds (default 300 = 5 minutes)
        
    Returns:
        Dict with scan results including vulnerabilities, platform info, etc.
        
    Raises:
        Exception: If scan fails or times out
    """
    logger.info(f"Starting pentest scan for {target_url} with mode {scan_mode}")
    
    # Build command
    cmd = [
        sys.executable,
        str(PENTEST_BRAIN_PATH),
        target_url,
        "--scan-mode", scan_mode,
        "--execution-mode", execution_mode,
        "--report-format", "json",
        "--quiet",
    ]
    
    logger.info(f"Executing command: {' '.join(cmd)}")
    
    try:
        # Execute with timeout
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        
        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
        except asyncio.TimeoutError:
            process.kill()
            await process.wait()
            raise Exception(f"Scan timed out after {timeout} seconds")
        
        if process.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            logger.error(f"Pentest brain failed with return code {process.returncode}: {error_msg}")
            raise Exception(f"Scan failed: {error_msg}")
        
        # Parse JSON output
        try:
            result = json.loads(stdout.decode())
            logger.info(f"Scan completed successfully. Found {len(result.get('vulnerabilities', []))} vulnerabilities")
            return result
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse scan output as JSON: {e}")
            logger.error(f"Output was: {stdout.decode()[:500]}")
            raise Exception(f"Invalid scan output: {e}")
            
    except Exception as e:
        logger.error(f"Exception during scan execution: {e}")
        raise


def format_scan_result(raw_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Format raw scan result into standardized format for database storage
    
    Args:
        raw_result: Raw result from pentest brain
        
    Returns:
        Formatted result dict
    """
    vulnerabilities = raw_result.get("vulnerabilities", [])
    
    # Calculate vulnerability counts by severity
    critical_count = sum(1 for v in vulnerabilities if v.get("severity", "").lower() == "critical")
    high_count = sum(1 for v in vulnerabilities if v.get("severity", "").lower() == "high")
    medium_count = sum(1 for v in vulnerabilities if v.get("severity", "").lower() == "medium")
    low_count = sum(1 for v in vulnerabilities if v.get("severity", "").lower() == "low")
    
    return {
        "target": raw_result.get("target", ""),
        "scan_mode": raw_result.get("scan_mode", ""),
        "scan_date": raw_result.get("scan_date", datetime.utcnow().isoformat()),
        "platform_detected": raw_result.get("platform_detected", "Unknown"),
        "confidence": raw_result.get("confidence", 0.0),
        "vulnerabilities": vulnerabilities,
        "vulnerability_counts": {
            "critical": critical_count,
            "high": high_count,
            "medium": medium_count,
            "low": low_count,
            "total": len(vulnerabilities)
        },
        "scan_duration": raw_result.get("scan_duration", 0),
        "status": "completed"
    }


def generate_text_report(scan_result: Dict[str, Any]) -> str:
    """
    Generate a detailed text report from scan results
    
    Args:
        scan_result: Formatted scan result
        
    Returns:
        Text report string
    """
    lines = []
    lines.append("=" * 80)
    lines.append("AI PENETRATION TESTING BRAIN - SECURITY ASSESSMENT REPORT")
    lines.append("=" * 80)
    lines.append("")
    
    # Scan Information
    lines.append("SCAN INFORMATION")
    lines.append("-" * 80)
    lines.append(f"Target:                 {scan_result.get('target', 'Unknown')}")
    lines.append(f"Scan Date:              {scan_result.get('scan_date', 'Unknown')}")
    lines.append(f"Scanner Version:        3.9+")
    lines.append(f"Report ID:              RPT-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}")
    lines.append("")
    
    # Executive Summary
    counts = scan_result.get('vulnerability_counts', {})
    total = counts.get('total', 0)
    critical = counts.get('critical', 0)
    high = counts.get('high', 0)
    medium = counts.get('medium', 0)
    low = counts.get('low', 0)
    
    # Determine overall risk
    if critical > 0:
        risk_level = "CRITICAL"
    elif high > 0:
        risk_level = "HIGH"
    elif medium > 0:
        risk_level = "MEDIUM"
    elif low > 0:
        risk_level = "LOW"
    else:
        risk_level = "MINIMAL"
    
    lines.append("EXECUTIVE SUMMARY")
    lines.append("-" * 80)
    lines.append(f"Overall Risk Level:     {risk_level}")
    lines.append(f"Total Vulnerabilities:  {total}")
    lines.append(f"- Critical:           {critical}")
    lines.append(f"- High:               {high}")
    lines.append(f"- Medium:             {medium}")
    lines.append(f"- Low:                {low}")
    lines.append(f"- Informational:      0")
    lines.append("")
    
    # Key Findings
    vulnerabilities = scan_result.get('vulnerabilities', [])
    if vulnerabilities:
        lines.append("KEY FINDINGS")
        lines.append("-" * 80)
        for i, vuln in enumerate(vulnerabilities[:10], 1):  # Top 10
            severity = vuln.get('severity', 'Unknown').upper()
            vuln_type = vuln.get('type', 'Unknown Vulnerability')
            lines.append(f"{i}. [{severity}] {vuln_type}")
        lines.append("")
    
    # Platform Detection
    lines.append("PLATFORM DETECTION")
    lines.append("-" * 80)
    lines.append(f"Platform:               {scan_result.get('platform_detected', 'Unknown')}")
    lines.append(f"Confidence:             {scan_result.get('confidence', 0.0):.2f}")
    lines.append("")
    
    # Detailed Vulnerability Findings
    if vulnerabilities:
        lines.append("DETAILED VULNERABILITY FINDINGS")
        lines.append("=" * 80)
        for i, vuln in enumerate(vulnerabilities, 1):
            lines.append(f"[{i}] {vuln.get('type', 'Unknown').upper()}")
            lines.append("-" * 80)
            lines.append(f"Severity:               {vuln.get('severity', 'Unknown').upper()}")
            lines.append("")
            lines.append("DESCRIPTION:")
            lines.append(vuln.get('description', 'No description available'))
            lines.append("")
            if vuln.get('affected_endpoint'):
                lines.append("AFFECTED ENDPOINT:")
                lines.append(vuln['affected_endpoint'])
                lines.append("")
            if vuln.get('evidence'):
                lines.append("EVIDENCE:")
                evidence = vuln['evidence']
                if isinstance(evidence, dict):
                    for key, value in evidence.items():
                        lines.append(f"{key}: {value}")
                else:
                    lines.append(str(evidence))
                lines.append("")
            if vuln.get('recommendation'):
                lines.append("REMEDIATION:")
                lines.append(vuln['recommendation'])
            lines.append("")
            lines.append("=" * 80)
        lines.append("")
    
    # Recommendations Summary
    lines.append("RECOMMENDATIONS SUMMARY")
    lines.append("=" * 80)
    if critical > 0 or high > 0:
        lines.append("SHORT-TERM ACTIONS (High - Fix within 1 week):")
        for i, vuln in enumerate([v for v in vulnerabilities if v.get('severity', '').lower() in ['critical', 'high']], 1):
            lines.append(f"{i}. Fix {vuln.get('type', 'Unknown')}")
        lines.append("")
    if medium > 0:
        lines.append("LONG-TERM ACTIONS (Medium - Fix within 1 month):")
        for i, vuln in enumerate([v for v in vulnerabilities if v.get('severity', '').lower() == 'medium'], 1):
            lines.append(f"{i}. Fix {vuln.get('type', 'Unknown')}")
        lines.append("")
    
    # Footer
    lines.append("=" * 80)
    lines.append("END OF REPORT")
    lines.append("=" * 80)
    lines.append("Generated by: AI Penetration Testing Brain v3.9+")
    lines.append("Report Format: Detailed Text Report v1.0")
    lines.append(f"Confidence Level: {scan_result.get('confidence', 0.0):.0%}")
    lines.append("False Positive Rate: <0.5%")
    lines.append("")
    lines.append("For questions or support: support@pentestbrain.ai")
    lines.append("Premium users: Enable auto-fix to deploy these fixes automatically")
    lines.append("")
    
    return "\n".join(lines)
